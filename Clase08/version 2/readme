8.1 Fundamentos de Asincronismo
Introducci√≥n al asincronismo

El asincronismo permite que JavaScript ejecute tareas en segundo plano sin detener el flujo principal del programa. Esto es clave cuando trabajamos con operaciones lentas o dependientes de recursos externos. Para entenderlo, primero vamos a comparar la ejecuci√≥n sincr√≥nica con la asincr√≥nica.

Ejecuci√≥n sincr√≥nica

En la ejecuci√≥n sincr√≥nica, el c√≥digo se ejecuta l√≠nea por l√≠nea, esperando que cada operaci√≥n termine antes de continuar. Si una funci√≥n tarda mucho tiempo en completarse, el programa queda bloqueado hasta que finaliza. Este comportamiento puede provocar aplicaciones lentas o interfaces que no responden.

(Aqu√≠ se muestra el ejemplo de c√≥digo sincr√≥nico.)

Ejecuci√≥n asincr√≥nica

La ejecuci√≥n asincr√≥nica permite que el programa contin√∫e ejecut√°ndose mientras una tarea se procesa en segundo plano. JavaScript delega estas tareas y se encarga de ejecutar su resultado cuando est√° disponible, sin bloquear el resto del c√≥digo.

(Aqu√≠ se muestra el ejemplo con setTimeout.)

Event Loop

El Event Loop es el mecanismo que permite a JavaScript manejar el asincronismo. Se encarga de ejecutar las tareas pendientes cuando el stack de ejecuci√≥n queda libre. Por eso, el c√≥digo asincr√≥nico no siempre se ejecuta en el orden en que est√° escrito.

Relevancia en aplicaciones modernas

El asincronismo es fundamental para cargar datos, interactuar con APIs y mantener interfaces fluidas. JavaScript ofrece herramientas como callbacks, promesas y async/await para trabajar con este modelo de forma clara y eficiente, las cuales veremos a lo largo de la clase.

Transici√≥n al siguiente tema

Con estos conceptos claros, a continuaci√≥n vamos a trabajar con ejemplos pr√°cticos de asincronismo usando peticiones fetch, analizando c√≥mo manejar tanto los resultados como los errores que pueden surgir.


8.2 Profundizando en el Asincronismo
Call Stack y Event Loop en JavaScript

JavaScript es un lenguaje single-threaded, lo que significa que solo puede ejecutar una tarea a la vez. Para poder manejar operaciones lentas sin bloquear la aplicaci√≥n, utiliza dos conceptos clave: el Call Stack y el Event Loop. Entender estos mecanismos permite comprender c√≥mo JavaScript maneja el asincronismo.

Call Stack


El Call Stack es la estructura que controla la ejecuci√≥n del c√≥digo sincr√≥nico en JavaScript.

Cada vez que se llama a una funci√≥n, se agrega a la pila (stack).

Cuando la funci√≥n termina, se elimina de la pila y se contin√∫a con la siguiente funci√≥n que estaba esperando.

Si una funci√≥n tarda en finalizar, el Call Stack queda bloqueado y el resto del c√≥digo debe esperar.

üí° Ejemplo de la vida real:
Imagin√° que est√°s haciendo tareas en tu escritorio y vas apilando hojas:

Pon√©s la hoja A arriba ‚Üí hac√©s la tarea de A ‚Üí termin√°s ‚Üí sac√°s A.

Luego hac√©s la hoja B que estaba debajo.

Finalmente hac√©s la hoja C.

El Call Stack funciona igual: √∫ltima que entra, primera que sale (LIFO: Last In, First Out).

Por qu√© JavaScript usa el Call Stack

JavaScript es un lenguaje single-threaded (un solo hilo).

Solo puede ejecutar una cosa a la vez, entonces necesita controlar qu√© funci√≥n se est√° ejecutando y cu√°les esperan su turno.

Gracias al Call Stack, JavaScript mantiene el orden de ejecuci√≥n y sabe cu√°ndo cada funci√≥n termin√≥ para pasar a la siguiente.

üëâ Este comportamiento se observa en el ejemplo sincr√≥nico trabajado en Visual Studio Code.

Qu√© es el Event Loop?

El Event Loop es el mecanismo que permite a JavaScript manejar operaciones asincr√≥nicas (temporizadores, solicitudes HTTP, promesas) aunque JavaScript sea single-threaded.

Mientras que el Call Stack maneja las funciones sincr√≥nicas, el Event Loop supervisa la cola de tareas (Callback Queue), donde se colocan las operaciones asincr√≥nicas una vez que est√°n listas.

Cuando el Call Stack queda vac√≠o, el Event Loop toma la primera tarea de la cola y la coloca en el Call Stack para su ejecuci√≥n.

Esto permite que la interfaz siga siendo receptiva y que operaciones largas no bloqueen el programa.

Gracias al Event Loop, JavaScript puede manejar:

Temporizadores: setTimeout, setInterval

Promesas: Promise

Operaciones de I/O

sin bloquear el Call Stack, asegurando que el c√≥digo sincr√≥nico siga ejecut√°ndose y la app se mantenga fluida.


üí° Analog√≠a r√°pida:

Call Stack = tu escritorio, donde hac√©s las tareas una a la vez.

Event Loop = un asistente que mira las tareas asincr√≥nicas (temporizadores, promesas) y te las trae cuando tu escritorio est√° libre.



üëâ Este funcionamiento se puede ver en los ejemplos asincr√≥nicos desarrollados en el archivo JavaScript del proyecto.

Relaci√≥n entre ambos

El Call Stack ejecuta el c√≥digo en orden y de forma bloqueante, mientras que el Event Loop permite que tareas lentas se ejecuten m√°s tarde sin detener la aplicaci√≥n. Gracias a esta combinaci√≥n, JavaScript puede ser eficiente y mantener una experiencia de usuario fluida.

---TEMPORIZADORES----

Temporizadores en JavaScript permiten ejecutar funciones en el futuro o repetidamente:

setTimeout(funci√≥n, tiempoMs) ‚Üí Ejecuta una funci√≥n una sola vez despu√©s de un retraso.

setInterval(funci√≥n, tiempoMs) ‚Üí Ejecuta una funci√≥n repetidamente a intervalos regulares.

clearTimeout / clearInterval ‚Üí Cancela un temporizador si ya no queremos que se ejecute.

üí° Importante: Los temporizadores son asincr√≥nicos, no bloquean el resto del c√≥digo. Por eso se integran con el Event Loop: esperan su turno en la cola de tareas y se ejecutan cuando el Call Stack est√° vac√≠o.

8.4 Control de Errores en JavaScript
Introducci√≥n al Control de Errores

Cuando escribimos c√≥digo, no siempre todo sale como esperamos.
Puede fallar un c√°lculo, un dato puede no existir o una operaci√≥n puede no ser v√°lida.
Si estos errores no se manejan correctamente, la aplicaci√≥n puede romperse, dejar de responder o mostrar comportamientos inesperados.

Para evitar esto, JavaScript nos permite detectar errores y reaccionar de forma controlada usando la estructura:

try ‚Äì catch ‚Äì finally

Esto es fundamental para escribir aplicaciones m√°s seguras, estables y f√°ciles de mantener.

¬øQu√© es try-catch-finally?

El bloque try-catch-finally se utiliza para ejecutar c√≥digo que puede fallar, capturar el error si ocurre y decidir qu√© hacer en ese caso.

Est√° compuesto por tres partes:

üîπ try

El bloque try contiene el c√≥digo que puede generar un error.
JavaScript intenta ejecutar este c√≥digo normalmente.

Si no ocurre ning√∫n error, el bloque catch se ignora.

Si ocurre un error, la ejecuci√≥n del try se detiene inmediatamente y se pasa al catch.

üîπ catch

El bloque catch se ejecuta solo si ocurre un error en el try.

Aqu√≠ se maneja el error:

Mostrar un mensaje al usuario

Evitar que la aplicaci√≥n se rompa

Explicar qu√© sali√≥ mal

El catch recibe un objeto error, que contiene informaci√≥n sobre el problema.

üîπ finally

El bloque finally es opcional, pero muy √∫til.

Se ejecuta siempre, ocurra o no un error.
Sirve para tareas que deben ejecutarse pase lo que pase, como:

Ocultar un loader

Limpiar mensajes

Restablecer estados

Ejemplo conceptual (idea, no c√≥digo todav√≠a)

Imagin√° esta situaci√≥n:

Intentamos hacer una operaci√≥n
Si algo sale mal, avisamos
Al final, ordenamos todo igual

Eso es exactamente lo que hace try-catch-finally.

¬øPor qu√© es importante usar control de errores?

Porque permite:

Evitar que la aplicaci√≥n se rompa

Mostrar mensajes claros en lugar de fallos silenciosos

Controlar qu√© pasa cuando algo no sale bien

Mantener una buena experiencia de usuario

En aplicaciones reales, los errores existen, lo importante es c√≥mo los manejamos.

Lanzar errores manualmente (throw)

Adem√°s de capturar errores, JavaScript permite crear nuestros propios errores usando throw.

Esto se usa cuando detectamos una situaci√≥n inv√°lida, por ejemplo:

Datos incorrectos

Operaciones no permitidas

Valores que no deber√≠an existir

Lanzar errores permite:

Detener la ejecuci√≥n en ese punto

Forzar que el error sea manejado con catch

Control de Errores y Asincron√≠a

Cuando trabajamos con:

temporizadores

promesas

async / await

fetch

Los errores no siempre ocurren en el mismo momento en que escribimos el c√≥digo.

Por eso:

En c√≥digo asincr√≥nico usamos try-catch junto con async/await

O .catch() cuando usamos promesas

Esto permite manejar errores sin bloquear la aplicaci√≥n y sin romper el flujo.

Buenas Pr√°cticas de Manejo de Errores

‚úî Usar try-catch solo donde realmente puede fallar algo
‚úî Mostrar mensajes claros y entendibles
‚úî No ignorar errores silenciosamente
‚úî No abusar del try-catch para todo
‚úî Usar finally para limpieza y estados finales
‚úî Pensar el error como parte normal del flujo del programa

Conclusi√≥n

El control de errores no es solo un concepto te√≥rico, es una herramienta clave en aplicaciones reales.

Usar correctamente try-catch-finally permite:

Anticiparse a problemas

Mantener la aplicaci√≥n funcionando

Dar feedback claro al usuario

Escribir c√≥digo m√°s profesional

En los pr√≥ximos ejemplos veremos c√≥mo aplicar esto directamente en el DOM, con botones y mensajes visibles, para entender claramente qu√© pasa cuando ocurre un error y c√≥mo manejarlo.

Cuando quieras, seguimos punto por punto con ejemplos pr√°cticos, arrancando por:
üëâ try-catch m√°s simple posible con bot√≥n y error visible
y despu√©s avanzamos a:

throw

finally

errores en asincron√≠a   