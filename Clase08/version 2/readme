8.1 Fundamentos de Asincronismo
Introducci贸n al asincronismo

El asincronismo permite que JavaScript ejecute tareas en segundo plano sin detener el flujo principal del programa. Esto es clave cuando trabajamos con operaciones lentas o dependientes de recursos externos. Para entenderlo, primero vamos a comparar la ejecuci贸n sincr贸nica con la asincr贸nica.

Ejecuci贸n sincr贸nica

En la ejecuci贸n sincr贸nica, el c贸digo se ejecuta l铆nea por l铆nea, esperando que cada operaci贸n termine antes de continuar. Si una funci贸n tarda mucho tiempo en completarse, el programa queda bloqueado hasta que finaliza. Este comportamiento puede provocar aplicaciones lentas o interfaces que no responden.

(Aqu铆 se muestra el ejemplo de c贸digo sincr贸nico.)

Ejecuci贸n asincr贸nica

La ejecuci贸n asincr贸nica permite que el programa contin煤e ejecut谩ndose mientras una tarea se procesa en segundo plano. JavaScript delega estas tareas y se encarga de ejecutar su resultado cuando est谩 disponible, sin bloquear el resto del c贸digo.

(Aqu铆 se muestra el ejemplo con setTimeout.)

Event Loop

El Event Loop es el mecanismo que permite a JavaScript manejar el asincronismo. Se encarga de ejecutar las tareas pendientes cuando el stack de ejecuci贸n queda libre. Por eso, el c贸digo asincr贸nico no siempre se ejecuta en el orden en que est谩 escrito.

Relevancia en aplicaciones modernas

El asincronismo es fundamental para cargar datos, interactuar con APIs y mantener interfaces fluidas. JavaScript ofrece herramientas como callbacks, promesas y async/await para trabajar con este modelo de forma clara y eficiente, las cuales veremos a lo largo de la clase.

Transici贸n al siguiente tema

Con estos conceptos claros, a continuaci贸n vamos a trabajar con ejemplos pr谩cticos de asincronismo usando peticiones fetch, analizando c贸mo manejar tanto los resultados como los errores que pueden surgir.


8.2 Profundizando en el Asincronismo
Call Stack y Event Loop en JavaScript

JavaScript es un lenguaje single-threaded, lo que significa que solo puede ejecutar una tarea a la vez. Para poder manejar operaciones lentas sin bloquear la aplicaci贸n, utiliza dos conceptos clave: el Call Stack y el Event Loop. Entender estos mecanismos permite comprender c贸mo JavaScript maneja el asincronismo.

Call Stack

El Call Stack es la estructura que controla la ejecuci贸n del c贸digo sincr贸nico. Cada vez que se llama a una funci贸n, esta se agrega a la pila. Cuando termina, se elimina y se contin煤a con la siguiente.

Si una funci贸n tarda en finalizar, el Call Stack queda bloqueado y el resto del c贸digo debe esperar.

 Este comportamiento se observa en el ejemplo sincr贸nico trabajado en Visual Studio Code.

Event Loop

El Event Loop permite que JavaScript maneje tareas asincr贸nicas sin bloquear el hilo principal. Mientras el Call Stack ejecuta el c贸digo sincr贸nico, el Event Loop se encarga de verificar cu谩ndo una tarea asincr贸nica puede ejecutarse.

Cuando el Call Stack queda vac铆o, el Event Loop env铆a la siguiente tarea pendiente para su ejecuci贸n.

 Este funcionamiento se puede ver en los ejemplos asincr贸nicos desarrollados en el archivo JavaScript del proyecto.

Relaci贸n entre ambos

El Call Stack ejecuta el c贸digo en orden y de forma bloqueante, mientras que el Event Loop permite que tareas lentas se ejecuten m谩s tarde sin detener la aplicaci贸n. Gracias a esta combinaci贸n, JavaScript puede ser eficiente y mantener una experiencia de usuario fluida.