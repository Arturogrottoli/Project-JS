8.1 Fundamentos de Asincronismo
Introducci√≥n al asincronismo

El asincronismo permite que JavaScript ejecute tareas en segundo plano sin detener el flujo principal del programa. Esto es clave cuando trabajamos con operaciones lentas o dependientes de recursos externos. Para entenderlo, primero vamos a comparar la ejecuci√≥n sincr√≥nica con la asincr√≥nica.

Ejecuci√≥n sincr√≥nica

En la ejecuci√≥n sincr√≥nica, el c√≥digo se ejecuta l√≠nea por l√≠nea, esperando que cada operaci√≥n termine antes de continuar. Si una funci√≥n tarda mucho tiempo en completarse, el programa queda bloqueado hasta que finaliza. Este comportamiento puede provocar aplicaciones lentas o interfaces que no responden.

(Aqu√≠ se muestra el ejemplo de c√≥digo sincr√≥nico.)

Ejecuci√≥n asincr√≥nica

La ejecuci√≥n asincr√≥nica permite que el programa contin√∫e ejecut√°ndose mientras una tarea se procesa en segundo plano. JavaScript delega estas tareas y se encarga de ejecutar su resultado cuando est√° disponible, sin bloquear el resto del c√≥digo.

(Aqu√≠ se muestra el ejemplo con setTimeout.)

Event Loop

El Event Loop es el mecanismo que permite a JavaScript manejar el asincronismo. Se encarga de ejecutar las tareas pendientes cuando el stack de ejecuci√≥n queda libre. Por eso, el c√≥digo asincr√≥nico no siempre se ejecuta en el orden en que est√° escrito.

Relevancia en aplicaciones modernas

El asincronismo es fundamental para cargar datos, interactuar con APIs y mantener interfaces fluidas. JavaScript ofrece herramientas como callbacks, promesas y async/await para trabajar con este modelo de forma clara y eficiente, las cuales veremos a lo largo de la clase.

Transici√≥n al siguiente tema

Con estos conceptos claros, a continuaci√≥n vamos a trabajar con ejemplos pr√°cticos de asincronismo usando peticiones fetch, analizando c√≥mo manejar tanto los resultados como los errores que pueden surgir.


8.2 Profundizando en el Asincronismo
Call Stack y Event Loop en JavaScript

JavaScript es un lenguaje single-threaded, lo que significa que solo puede ejecutar una tarea a la vez. Para poder manejar operaciones lentas sin bloquear la aplicaci√≥n, utiliza dos conceptos clave: el Call Stack y el Event Loop. Entender estos mecanismos permite comprender c√≥mo JavaScript maneja el asincronismo.

Call Stack


El Call Stack es la estructura que controla la ejecuci√≥n del c√≥digo sincr√≥nico en JavaScript.

Cada vez que se llama a una funci√≥n, se agrega a la pila (stack).

Cuando la funci√≥n termina, se elimina de la pila y se contin√∫a con la siguiente funci√≥n que estaba esperando.

Si una funci√≥n tarda en finalizar, el Call Stack queda bloqueado y el resto del c√≥digo debe esperar.

üí° Ejemplo de la vida real:
Imagin√° que est√°s haciendo tareas en tu escritorio y vas apilando hojas:

Pon√©s la hoja A arriba ‚Üí hac√©s la tarea de A ‚Üí termin√°s ‚Üí sac√°s A.

Luego hac√©s la hoja B que estaba debajo.

Finalmente hac√©s la hoja C.

El Call Stack funciona igual: √∫ltima que entra, primera que sale (LIFO: Last In, First Out).

Por qu√© JavaScript usa el Call Stack

JavaScript es un lenguaje single-threaded (un solo hilo).

Solo puede ejecutar una cosa a la vez, entonces necesita controlar qu√© funci√≥n se est√° ejecutando y cu√°les esperan su turno.

Gracias al Call Stack, JavaScript mantiene el orden de ejecuci√≥n y sabe cu√°ndo cada funci√≥n termin√≥ para pasar a la siguiente.

üëâ Este comportamiento se observa en el ejemplo sincr√≥nico trabajado en Visual Studio Code.

Qu√© es el Event Loop?

El Event Loop es el mecanismo que permite a JavaScript manejar operaciones asincr√≥nicas (temporizadores, solicitudes HTTP, promesas) aunque JavaScript sea single-threaded.

Mientras que el Call Stack maneja las funciones sincr√≥nicas, el Event Loop supervisa la cola de tareas (Callback Queue), donde se colocan las operaciones asincr√≥nicas una vez que est√°n listas.

Cuando el Call Stack queda vac√≠o, el Event Loop toma la primera tarea de la cola y la coloca en el Call Stack para su ejecuci√≥n.

Esto permite que la interfaz siga siendo receptiva y que operaciones largas no bloqueen el programa.

Gracias al Event Loop, JavaScript puede manejar:

Temporizadores: setTimeout, setInterval

Promesas: Promise

Operaciones de I/O

sin bloquear el Call Stack, asegurando que el c√≥digo sincr√≥nico siga ejecut√°ndose y la app se mantenga fluida.


üí° Analog√≠a r√°pida:

Call Stack = tu escritorio, donde hac√©s las tareas una a la vez.

Event Loop = un asistente que mira las tareas asincr√≥nicas (temporizadores, promesas) y te las trae cuando tu escritorio est√° libre.



üëâ Este funcionamiento se puede ver en los ejemplos asincr√≥nicos desarrollados en el archivo JavaScript del proyecto.

Relaci√≥n entre ambos

El Call Stack ejecuta el c√≥digo en orden y de forma bloqueante, mientras que el Event Loop permite que tareas lentas se ejecuten m√°s tarde sin detener la aplicaci√≥n. Gracias a esta combinaci√≥n, JavaScript puede ser eficiente y mantener una experiencia de usuario fluida.

---TEMPORIZADORES----

Temporizadores en JavaScript permiten ejecutar funciones en el futuro o repetidamente:

setTimeout(funci√≥n, tiempoMs) ‚Üí Ejecuta una funci√≥n una sola vez despu√©s de un retraso.

setInterval(funci√≥n, tiempoMs) ‚Üí Ejecuta una funci√≥n repetidamente a intervalos regulares.

clearTimeout / clearInterval ‚Üí Cancela un temporizador si ya no queremos que se ejecute.

üí° Importante: Los temporizadores son asincr√≥nicos, no bloquean el resto del c√≥digo. Por eso se integran con el Event Loop: esperan su turno en la cola de tareas y se ejecutan cuando el Call Stack est√° vac√≠o.